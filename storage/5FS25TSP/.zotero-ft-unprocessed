{"indexedPages":14,"totalPages":14,"version":"244","text":"Neuron\nArticle\n\nGenerating Coherent Patterns of Activity from Chaotic Neural Networks\nDavid Sussillo1,* and L.F. Abbott1,* 1Department of Neuroscience, Department of Physiology and Cellular Biophysics, Columbia University College of Physicians and Surgeons, New York, NY 10032-2695, USA *Correspondence: sussillo@neurotheory.columbia.edu (D.S.), lfa2103@columbia.edu (L.F.A.) DOI 10.1016/j.neuron.2009.07.018\n\nSUMMARY\nNeural circuits display complex activity patterns both spontaneously and when responding to a stimulus or generating a motor output. How are these two forms of activity related? We develop a procedure called FORCE learning for modifying synaptic strengths either external to or within a model neural network to change chaotic spontaneous activity into a wide variety of desired activity patterns. FORCE learning works even though the networks we train are spontaneously chaotic and we leave feedback loops intact and unclamped during learning. Using this approach, we construct networks that produce a wide variety of complex output patterns, input-output transformations that require memory, multiple outputs that can be switched by control inputs, and motor patterns matching human motion capture data. Our results reproduce data on premovement activity in motor and premotor cortex, and suggest that synaptic plasticity may be a more rapid and powerful modulator of network activity than generally appreciated.\nINTRODUCTION\nWhen we voluntarily move a limb or perform some other motor action, what is the source of the neural activity that initiates and carries out this behavior? We explore the idea that such actions arise from the reorganization of spontaneous neural activity. This hypothesis raises another question: How can apparently chaotic spontaneous activity be reorganized into the coherent patterns required to generate controlled actions? Following, but modifying and extending, earlier work (Jaeger and Haas, 2004; Maass et al., 2007), we show how external feedback loops or internal synaptic modiﬁcations can be used to alter the chaotic activity of a recurrently connected neural network and generate complex but controlled outputs.\nTraining a neural network is a process through which network parameters (typically synaptic strengths) are modiﬁed on the basis of output errors until a desired response is produced. Researchers in the machine learning and computer vision communities have developed powerful methods for training artiﬁcial neural networks to perform complex tasks (Rumelhart and McClelland, 1986; Hinton et al., 2006), but these apply predom-\n\ninantly to networks with feedforward architectures. Biological networks tend to be connected in a highly recurrent manner. Training procedures have also been developed for recurrently connected neural networks (Rumelhart et al., 1986; Williams and Zipser, 1989; Pearlmutter, 1989; Atiya and Parlos, 2000), but these are more computationally demanding and difﬁcult to use than feedforward learning algorithms, and there are fundamental limitations to their applicability (Doya, 1992). In particular, these algorithms generally will not converge if applied to recurrent neural networks with chaotic activity, that is, activity that is irregular and exponentially sensitive to initial conditions (Abarbanel et al., 2008). This limitation is severe because models of spontaneously active neural circuits typically exhibit chaotic dynamics. For example, spiking models of spontaneous activity in cortical circuits (van Vreeswijk and Sompolinsky, 1996; Amit and Brunel, 1997; Brunel, 2000), which can generate realistic patterns of activity, and the analogous spontaneously active ﬁring-rate model networks that we use here have chaotic dynamics (Sompolinsky et al., 1988).\nTo develop a successful training procedure for recurrent neural networks, we must solve three problems. First, feeding erroneous output back into a network during training can cause its activity to deviate so far from what is needed that learning fails to converge. In previous work (Jaeger and Haas, 2004), this problem was avoided by removing all errors from the signal fed back into the network. In addition to the usual synaptic modiﬁcation, this scheme required a mechanism for removing feedback errors, and it is difﬁcult to see how this latter requirement could be met in a biological system. Furthermore, feeding back a signal that is identical to the desired network output prevents the network from sampling ﬂuctuations during training, which can lead to stability problems in the ﬁnal network. Here, we show how the synaptic modiﬁcation procedure itself can be used to control the feedback signal, without any other mechanism being required, in a manner that allows ﬂuctuations to be sampled and stabilized. For reasons given below, we call this procedure FORCE learning.\nA second problem with training that is particularly severe in recurrent networks is credit assignment for output errors. Credit assignment amounts to ﬁguring out which neurons and synapses are most responsible for output errors and therefore most in need of modiﬁcation. This problem is particularly challenging for network units that do not produce the output directly. Jaeger and Haas (2004) dealt with this issue by restricting modiﬁcation solely to synapses directly driving network output. Initially, we follow their lead in this, using the architecture of\n\n544 Neuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc.\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\nFigure 1A. However, the power of FORCE learning allows us to\n\nA\n\ntrain networks with the architectures shown in Figures 1B and\n\n1C, in which modiﬁcations are not restricted to network outputs.\n\nFor reasons discussed below, these architectures are more\n\nbiologically plausible than the network in Figure 1A.\n\nThe third problem we address is training in the face of chaotic\n\nspontaneous activity. Jaeger and Haas (2004) avoided this\n\nproblem by starting with networks that were inactive in the\n\nabsence of input (which is the basis for calling them echo-state\n\nnetworks). As we show in the Results, there are signiﬁcant\n\nadvantages in using a network that exhibits chaotic activity prior\n\nto training. To exploit these advantages, however, we must avoid\n\nchaotic network activity during training. The solution for learning\n\nin a recurrent network and for suppressing chaos turn out to be\n\nB\n\none and the same: synaptic modiﬁcations must be strong and\n\nrapid during the initial phases of training. This is precisely what\n\nthe FORCE procedure achieves.\n\nFORCE learning operates quite differently from traditional\n\ntraining in neural networks. Usually, training consists of perform-\n\ning a sequence of modiﬁcations that slowly reduce initially large\n\nerrors in network output. In FORCE learning, errors are always\n\nsmall, even from the beginning of the training process. As\n\na result, the goal of training is not signiﬁcant error reduction,\n\nbut rather reducing the amount of modiﬁcation needed to keep\n\nthe errors small. By the end of the training period, modiﬁcation\n\nis no longer needed, and the network can generate the desired\n\noutput autonomously.\n\nFrom a machine learning point of view, the FORCE procedure\n\nwe propose provides a powerful algorithm for constructing\n\nC\n\nrecurrent neural networks that generate complex and control-\n\nlable patterns of activity either in the absence of or in response\n\nto input. From a biological perspective, it can be viewed either\n\nas a model for training-induced modiﬁcation or, more conserva-\n\ntively, as a method for building functioning circuit models for\n\nfurther study. Either way, our approach introduces a novel way\n\nto think about learning in neural networks and to make contact\n\nwith experimental data.\n\nRESULTS\nThe recurrent network that forms the basis of our studies is a conventional model in which the outputs of individual neurons are characterized by ﬁring rates and neurons are sparsely interconnected through excitatory and inhibitory synapses of various strengths (Experimental Procedures). Following ideas developed in the context of liquid-state (Maass et al., 2002) and echo-state (Jaeger, 2003) models, we assume that this basic network is not designed for any speciﬁc task but is instead a general purpose dynamical system that will be co-opted for particular applications through subsequent synaptic modiﬁcation. As a result, the connectivity and synaptic strengths of the network are chosen randomly (Experimental Procedures). For the parameters we use, the initial state of the network is chaotic (Figure 2A).\nTo specify a task for the networks of Figure 1, we must deﬁne their outputs. In a full model, this would involve simulating activity all the way out to the periphery. In the absence of such a complete model, we need to have a way of describing what\n\nFigure 1. Network Architectures In all three cases, a recurrent generator network with ﬁring rates r drives a linear readout unit with output z through weights w (red) that are modiﬁed during training. Only connections shown in red are subject to modiﬁcation. (A) Feedback to the generator network (large network circle) is provided by the readout unit. (B) Feedback to the generator network is provided by a separate feedback network (smaller network circle). Neurons of the feedback network are recurrently connected and receive input from the generator network through synapses of strength JFG (red), which are modiﬁed during training. (C) A network with no external feedback. Instead, feedback is generated within the network and modiﬁed by applying FORCE learning to the synapses with strengths JGG internal to the network (red).\nthe network is ‘‘doing,’’ and here we follow another suggestion from the liquid- and echo-state approach (Maass et al., 2002; Jaeger, 2003; see also Buonomano and Merzenich, 1995). We deﬁne the network output through a weighted sum of its activities. Denoting the activities of the network neurons at time t by assembling them into a column vector r(t) and the weights\n\nNeuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc. 545\n\nA\nSpontaneous Activity\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\nB\nLearning\n\nC\nPost-Learning\n\n600msec D\nPeriodic\n\nE\nComplicated periodic\n\nF\nExtremely noisy target\n\n1.2s\nG Discontinuous target\n\n1.2s\n\nH\n\nLorenz attractor\n\n600ms\n1.2s\nI Sine wave w/ period 6\n\n600ms\n\nJ\n\nAperiodic\n\nSine wave w/ period 800\n\n1 2\n600ms\n\n1.2s\nK\n\n600ms\n\nFigure 2. FORCE Learning in the Network of Figure 1A (A–C) The FORCE training sequence. Network output, z, is in red, the ﬁring rates of 10 sample neurons from the network are in blue and the orange trace is the magnitude of the time derivative of the readout weight vector. (A) Before learning, network activity and output are chaotic. (B) During learning, the output matches the target function, in this case a triangle wave and the network activity is periodic because the readout weights ﬂuctuate rapidly. These ﬂuctuations subside as learning progresses. (C) After training, the network activity is periodic and the output matches the target without requiring any weight modiﬁcation. (D–K) Examples of FORCE learning. Red traces are network outputs after training with the network running autonomously. Green traces, where not covered by the matching red traces, are target functions. (D) Periodic function composed of four sinusoids. (E) Periodic function composed of 16 sinusoids. (F) Periodic function of four sinusoids learned from a noisy target function. (G) Square-wave. (H) The Lorenz attractor. Initial conditions of the network and the target were matched at the beginning of the traces. (I) Sine waves with periods of 60 ms and 8 s. (J) A one-shot example using a network with two readout units (circuit insert). The red trace is the output of unit 2. When unit 1 is activated, its feedback creates the ﬁxed point to the left of the left-most blue arrow, establishing the appropriate initial condition. Feedback from unit 2 then produces the sequence between the two blue arrows. When the sequence is concluded, the network output returns to being chaotic. (K) A low amplitude sine wave (right of gray line) for which the FORCE procedure does not control network chaos (blue traces) and learning fails.\n\n546 Neuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc.\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\nconnecting these neurons to the output by another column vector w, we deﬁne the network output as\n\nzðtÞ = wT rðtÞ:\n\n(1)\n\nMultiple readouts can be deﬁned in a similar manner, each with its own set of weights, but we restrict the discussion to one readout at this point. Although a linear readout is a useful way of deﬁning what we mean by the output of a network, it should be kept in mind that it is a computational stand-in for complex transduction circuitry. For this reason, we refer to the outputgenerating element as a unit rather than a neuron, and we call the components of w weights rather than synaptic strengths.\nHaving speciﬁed the network output, we can now deﬁne the task we want the network to perform, which is to set z(t) = f(t) for a predeﬁned target function f(t). In most of the examples we present, the goal is to make a network produce the target function in the absence of any input. Later, we consider the more conventional network task of generating outputs that depend on inputs to the network in a speciﬁed way. Due to stability issues, this is an easier task than generating target functions without inputs, so we mainly focus on the no-input case.\nIn the initial instantiation of our model (Figure 1A), we follow Jaeger and Haas (2004) and modify only the output weight vector w. All other network connections are left unchanged from their initial, randomly chosen values. The critical element that makes such a procedure possible is a feedback loop that carries the output z back into the network (Figure 1A). Learning cannot be accomplished in a network receiving no external input without including such a loop. The strengths of the synapses from this loop onto the neurons of the network are chosen randomly and left unmodiﬁed. The strength of the feedback synapses is of order 1 whereas that of synapses between neurons of the recurrent network is of order 1 over the square root of the number of recurrent synapses per neuron. The feedback synapses are made stronger so that the feedback pathway has an appreciable effect on the activity of the recurrent network. Later, when we consider the architectures of Figures 1B and 1C, we will no longer need such strong synapses.\n\nFORCE Learning Training in the presence of the feedback loop connecting the output in Figure 1A back to the network is challenging because modifying the readout weights produces delayed effects that can be difﬁcult to calculate. Modifying w has a direct effect on the output z given by Equation 1, and it is easy to determine how to change w to make z closer to f through this direct effect. However, the feedback loop in Figure 1A gives rise to a delayed effect when the resulting change in the output caused by modifying w propagates repeatedly along the feedback pathway and through the network, changing network activities. Because of this delayed effect, a weight modiﬁcation that at ﬁrst appears to bring z closer to f may later cause it to deviate away. This problem of delayed effects arises when attempting to modify synapses in any recurrent architecture, including those of Figures 1B and 1C.\nAs stated in the Introduction, Jaeger and Haas (2004) eliminated the problem of delayed effects by clamping feedback\n\nduring learning. In other words, the output of the network, given by Equation 1 was compared with f to determine an error that controlled modiﬁcation of the readout weights, but this output was not fed back to the network during training. Instead the feedback pathway was clamped to the target function f. The true output was only fed back to the network after training was completed.\nWe take another approach, which does not require any clamping or manipulation of the feedback pathway, it relies solely on error-based modiﬁcation of the readout weights. In this scheme, we allow output errors to be fed back into the network, but we keep them small by making rapid and effective weight modiﬁcations. As long as output errors are small enough, they can be fed back without disrupting learning, i.e., without introducing signiﬁcant delayed, reverberating effects. Because the method requires tight control of a small (ﬁrst-order) error, we call it ﬁrst-order reduced and controlled error or FORCE learning. Although the FORCE procedure holds the feedback signal close to its desired value, it does not completely clamp it. This difference, although numerically small, has extremely signiﬁcant implications for network stability. Small differences between the actual and desired output of the network during training allow the learning procedure to sample instabilities in the recurrent network and stabilize them.\nA learning algorithm suitable for FORCE learning must rapidly reduce the magnitude of the difference between the actual and desired output to a small value, and then keep it small while searching for and eventually ﬁnding a set of ﬁxed readout weights that can maintain a small error without further modiﬁcation. A number of algorithms are capable of doing this (Discussion). All of them involve updates to the values of the weights at times separated by an interval Dt. Each update consists of evaluating the output of the network, determining how far this output deviates from the target function, and modifying the readout weights accordingly. Note that Dt is the interval of time between modiﬁcations of the readout weights, not the basic integration time step for the network simulation, which can be smaller than Dt.\nAt time t, the training procedure starts by sampling the network output, which is given at this point by wT (t À Dt)r(t). The reason that the weights appear here evaluated at time t À Dt is that they have not yet been updated by the modiﬁcation procedure, so they take the same values that they had at the end of the previous update. Comparing this output with the desired target output f(t), we deﬁne the error\n\neÀðtÞ = wT ðt À DtÞrðtÞ À fðtÞ:\n\n(2)\n\nThe minus subscript signiﬁes that this is the error prior to the weight update at time t. The next step in the training process is to update the weights from w(tÀDt) to w(t) in a way that reduces the magnitude of e_(t). Immediately after the weight update, the output of the network is wT(t)r(t), assuming that the weights are modiﬁed rapidly on the scale of network evolution (Discussion). Thus, the error after the weight update is\n\ne + ðtÞ = wT ðtÞrðtÞ À fðtÞ;\n\n(3)\n\nwith the plus subscript signifying the error after the weights have been updated.\n\nNeuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc. 547\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\nThe goal of any weight modiﬁcation scheme is to reduce errors by making je+(t)j < jeÀ(t)j and also to converge to a solution in which the weight vector is no longer changing so that training can be terminated. This latter condition corresponds to making e+(t)/ eÀ(t) /1 by the end of training. In most training procedures, these two conditions are accompanied by a steady reduction in the magnitude of both errors (e+ and eÀ) over time, which are both quite large during the early stages of training. FORCE learning is unusual in that the magnitudes of these errors are small throughout the learning process, although they are similarly reduced over time. This is done by making a large reduction in their size at the time of the ﬁrst weight update and then maintaining small errors throughout the training process that decrease with time.\nIf the training process is initialized at time t = 0, the ﬁrst weight update will occur at time Dt. A weight modiﬁcation rule useful for FORCE learning should make je+(Dt)j, the error after the ﬁrst weight update has been performed, small, and then keep jeÀ(Dt)j small while slowly increasing e+(t)/eÀ(t) /1. Given a small magnitude of e+(t À Dt)), eÀ(t), which is equal to e+(t À Dt) plus a term of order Dt, is kept small by keeping the updating interval Dt sufﬁciently short. This means that learning can be performed with an error that starts and stays small.\nAs stated above, several modiﬁcation rules meet the requirements of FORCE learning, but the recursive least-squares (RLS) algorithm is particularly powerful (Haykin, 2002), and we use it here (see Discussion and Supplemental Data, available online, for another, simpler algorithm). In RLS modiﬁcation,\n\nwðtÞ = wðt À DtÞ À eÀðtÞPðtÞrðtÞ;\n\n(4)\n\nwhere P(t) is an N3N matrix that is updated at the same time as the weights according to the rule\n\nPðtÞ\n\n=\n\nPðt\n\nÀ\n\nDtÞ\n\nÀ\n\nPðt À DtÞrðtÞrT 1 + rT ðtÞPðt\n\nðtÞPðt À DtÞ À DtÞrðtÞ :\n\n(5)\n\nThe algorithm also requires an initial value for P, which is taken to be\n\nI\n\nPð0Þ = ;\n\n(6)\n\na\n\nwhere I is the identity matrix and a is a constant parameter.\n\nEquation 4 can be viewed as a standard delta-type rule (that\n\nis, a rule involving the product of the error and the presynaptic\n\nﬁring rate), but with multiple learning rates given by the matrix\n\nP, rather than by a scalar quantity. In this algorithm, P is a\n\nrunning estimate of the inverse of the correlation matrix of the\n\nnetwÀ oPrk P= t\n\nrates r rðtÞrT ðtÞ\n\n+plauIsÁÀa1\n\nregularization .\n\nterm\n\n(Haykin,\n\n2002),\n\ni.e.,\n\nIt is straightforward to show that the RLS rule satisﬁes the\n\nconditions necessary for FORCE learning. First, if we assume\n\nthat the initial readout weights are zero for simplicity (this is not\n\nessential), the above equations imply that the error after the ﬁrst\n\nweight update is\n\naf ðDtÞ\n\neÀðDtÞ = À a + rT ðDtÞrðDtÞ:\n\n(7)\n\nThe quantity rTr is of order N, the number of neurons in the network, so as long as a ( N, this error is small, and its size\n\ncan be controlled by adjusting a (see below). Furthermore, at\n\nsubsequent times, the above equations imply that\n\ne\n\n+\n\nðtÞ\n\n=\n\neÀ\n\nÀ ðtÞ 1\n\nÀ\n\nrT\n\nÁ ðtÞPðtÞrðtÞ ;\n\n(8)\n\nThe quantity rTPr varies over the course of learning from something close to 1 to a value that asymptotically approaches 0, and it is always positive. This means that the size of the error is reduced by the weight update, as required, and ultimately e+(t)/eÀ(t) / 1.\nThe parameter a, which acts as a learning rate, should be adjusted depending on the particular target function being learned. Small a values result in fast learning but sometimes make weight changes so rapid that the algorithm becomes unstable. In those cases, larger a should be used (subject to the constraint a ( N), but if a is too large, the FORCE algorithm may not keep the output close to the target function for a long enough time, causing learning to fail. In practice, values from 1 to 100 are effective, depending on the task.\nIn addition to dealing with feedback, FORCE learning must control the chaotic activity of the network during the training process. In this regard, it is important to note that the network we are considering is being driven through the feedback pathway by a signal approximately equal to the target function. Such an input can induce a transition between chaotic and nonchaotic states (Molgedey et al., 1992; Bertschinger and Natschla¨ ger, 2004; K. Rajan, L.F.A., and H. Sompolinsky, unpublished data). This is how the problem of chaotic activity can be avoided. Provided that the feedback signal is of sufﬁcient amplitude and frequency to induce a transition to a nonchaotic state (the required properties are discussed in K. Rajan, L.F.A., and H. Sompolinsky, unpublished data), learning can take place in the absence of chaotic activity, even though the network is chaotic prior to learning and afterwards there may exist additional chaotic trajectories.\n\nExamples of FORCE Learning Figures 2A–2C illustrates how the activity of an initially chaotic network can be modiﬁed so that it ends up producing a periodic, triangle-wave output autonomously. Initially, with the output weight vector w chosen randomly, the neurons in the network exhibit chaotic spontaneous activity, as does the network output (Figure 2A). When we start FORCE learning, the weights of the readout connections begin to ﬂuctuate rapidly, which immediately changes the activity of the network so that it is periodic rather than chaotic and forces the output to match the target triangle wave (Figure 2B). The progression of learning can be tracked by monitoring the size of the ﬂuctuations in the readout weights (orange trace in Figure 2B), which diminish over time as the learning procedure establishes a set of static weights that generate the target function without requiring modiﬁcation. At this point, learning can be turned off, and the network continues to generate the triangle wave output on its own indeﬁnitely (Figure 2C). The learning process is rapid, converging in only four cycles of the triangle wave in this example.\nFORCE learning can be used to modify networks that are initially in a chaotic state so that they autonomously produce a wide variety of outputs (Figures 2D–2K). In these examples,\n\n548 Neuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc.\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\nA\n1.2sec\nB\n\nC\n3\n\n0\n\nEigenvalue #50\n\n100\n\nlog10(eigenvalue)\n\n-3\n\n-6\n\nD\ntime\nE\n\nControlling\n\nLearning\n\nControlling\n\nLearned Learning\n\nControlling\n\nLearned\n\nLearning Controlling\n\nLearned Eigenvalue #50\n\nLearning 100\n\nPC 2\n\nFigure 3. Principal Component Analysis of Network Activity (A) Output after training a network to produce a sum of four sinusoids (red), and the approximation (brown) obtained using activity projected onto the 8 leading principal components. (B) Projections of network activity onto the leading eight PC vectors. (C) PCA eigenvalues for the network activity that generated the waveform in (A). Only the largest 100 of 1000 eigenvalues are shown. (D) Schematic showing the transition from control to learning phases of learning as a function of time and of PC eigenvalue. (E) Evolution of the projections of w onto the two leading PC vectors during learning starting from ﬁve different initial conditions. These values converge to the same point on all trials. (F) The same weight evolution but now including the projection onto PC vector 80 as a third dimension. The ﬁnal values of this projection are different on each of the 5 runs, resulting in the vertical line at the center of the ﬁgure. Nevertheless, all of these networks generate the output in A.\n\nPC 1\n\nand we do this by introducing a ﬁxed-\n\nF\n\npoint attractor as well as the network conﬁguration that produces the one-shot\n\nsequence. This is done by adding\n\na second readout unit to the network\n\nPC 80\n\nthat also provides feedback (Experi-\n\nmental Procedures; network diagram in\n\nFigure 2J). The ﬁrst feedback unit induces\n\nthe ﬁxed point corresponding to a\n\n1.2sec\n\nPC 2\n\nPC 1\n\nconstant z output (horizontal red line in\n\nFigure 2J), and then the second unit\n\ninduces the target pattern (red trace\n\ntraining typically converges in about 1000t, where t is the between the arrows in Figure 2J). As shown below, initialization\n\nbasic time constant of the network, which we set to 10 ms. This can also be achieved through appropriate input.\n\nmeans learning takes about 10 s of simulated time. Networks As discussed above, FORCE learning must induce a transition\n\ncan be trained to produce periodic functions of different in the network from chaotic to nonchaotic activity during training.\n\ncomplexity and form (Figures 2D–2G and 2I), even when the This requires an input to the network, through the feedback loop\n\ntarget function is corrupted by noise (Figure 2F). The dynamic in our case, of sufﬁcient amplitude. If we try to train a network to\n\nrange of the outputs that chaotic networks can be trained to generate a target function with too small an amplitude, the\n\ngenerate by FORCE learning is impressive. For example, a 1000 activity of the network neurons remains chaotic even after\n\nneuron network with a time constant of 10 ms can produce sine FORCE learning is activated (Figure 2K). In this case, learning\n\nwave outputs with periods ranging from 60 ms to 8 s (Figure 2I). does not converge to a successful solution. There are a number\n\nFORCE learning is not restricted to periodic functions. For of solutions to this problem. It is possible for the network to\n\nexample, a network can be trained to produce an output match- generate low amplitude oscillatory and nonoscillatory functions\n\ning one of the dynamic variables of the three-dimensional if these are displaced from zero by a constant shift. Alternatively,\n\nchaotic Lorenz attractor (Experimental Procedures; see also the networks shown in Figures 1B and 1C can be trained to\n\nJaeger and Haas, 2004), although in this case, because the generate low amplitude signals centered near zero.\n\ntarget is itself a chaotic process, a precise match between\n\noutput and target can only last for a ﬁnite amount of time (Fig- PCA Analysis of FORCE Learning\n\nure 2H). After the two traces diverge, the network still produces The activity of a network that has been modiﬁed by the FORCE\n\na trace that looks like it comes from the Lorenz model.\n\nprocedure to produce a particular output can be analyzed by\n\nFORCE learning can also produce a segment matching a one- principal component analysis (PCA). For a network producing\n\nshot, nonrepeating target function (Figure 2J). To produce such the periodic pattern shown in Figure 3A, the distribution of\n\na one-shot sequence, the network must be initialized properly, PCA eigenvalues (Figure 3C) indicates that the trajectory of\n\nNeuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc. 549\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\nnetwork activity lies primarily in a subspace that is of considerably lower dimension than the number of network neurons. The projections of the network activity vector r(t) onto the PC vectors form a set of orthogonal basis functions (Figure 3B) from with the target function is generated. An accurate approximation of the network output (brown trace in Figure 3A) can be generated using the basis functions derived from only the ﬁrst eight principal components (with components labeled in decreasing order of the size of their eigenvalues). These eight components are not the whole story, however, because, along with generating the target function, the network must be stable. If we express the readout weight vector in terms of its projections onto the PC vectors of the network activity, we ﬁnd that learning sets about the top 50 of these projections to uniquely speciﬁed values (Figure 3E). The remaining projections take different values from one learning trial to the next, depending on initial conditions (Figure 3F). This multiplicity of solutions greatly simpliﬁes the task of ﬁnding successful readout weights.\nThe uneven distribution of eigenvalues shown in Figure 3C illustrates why the RLS algorithm works so well for FORCE learning. As mentioned previously, the matrix P acts as a set of learning rates for the RLS algorithm. This is seen most clearly by shifting to a basis in which P is diagonal. Assuming learning has progressed long enough for P to have converged to the inverse correlation matrix of r, the diagonal basis is achieved by projecting w and r onto the PC vectors. Doing this, it is straightforward to show that the learning rate for the component of w aligned with PC vector a after M weight updates is 1/(Mla + a), where la is the corresponding PC eigenvalue. This rate divides the RLS process into two stages, one when M < a/la in which the major role of weight modiﬁcation is to control the output (set it close to f) and another when M > a/la in which the goal is learning, that is, ﬁnding a static weight that accomplishes the task. Components of w with large eigenvalues quickly enter the learning phase, whereas those with small eigenvalues spend more time in the control phase (Figure 3D). Controlling components with small eigenvalues allows weight projections in dimensions with large eigenvalues to be learned.\nThe learning rate for all components during the control phase is 1/a. During the learning phase, the rate for PC component a is proportional to 1/la . The average rate of change (as opposed to just the learning rate) of the projection of the outputpwﬃﬃeﬃﬃight vector onto principal component a is proportional to la=ðMla + aÞ because tpheﬃﬃﬃﬃfactor of r in Equation 4 introduces a term proportiopnaﬃﬃlﬃﬃ to la, so the full rate of change for large M goes as 1= la. This is exactly what it should be, because in the expression for z, this change is multiplied by the projection of r ontopPﬃﬃﬃCﬃ vector a, which again has an amplitude proportional to la. Thpusﬃﬃ,ﬃﬃ RLS, by having rates of change of w proportional to 1= la in the PC basis, allows all the projections to, potentially, contribute equally to the output of the network.\nComparison of Echo-State and FORCE Feedback In echo-state learning (Jaeger and Haas, 2004), the feedback signal during training was set equal to the target function f(t). In FORCE learning, the feedback signal is z(t) during training. To compare these two methods, we introduce a mixed feedback signal, setting the feedback equal to gf(t) + (1Àg)z(t) during\n\nA\n100\n\nB\n0.12\n\n% Trials Stabilized MAE\n\n80\n\n0.1\n\n0.08 60\n0.06\n40 0.04\n\n20\n\n0.02\n\n0 0 0.2 0.4 0.6 0.8 1\n\n0 0 0.05 0.1 0.15 0.2 0.25\n\nC\n\nFigure 4. Comparison of Different Mixtures of FORCE (g = 0) and Echo-State (g = 1) Feedback (A) Percent of trials resulting in stable generation of the target function. (B) Mean absolute error (MAE) between the output and target function after learning over the g range where learning converged. Error bars represent standard deviation. (C) Example run with output (red) and target function (green) for g = 1. The trajectory is unstable.\ntraining. Thus, g = 0 corresponds to FORCE learning and g = 1 to echo-state learning, with intermediate values interpolating between these two approaches.\nTraining to produce the output of Figure 3A, we ﬁnd the network is only stable on the majority of trials when g < 0.15, in other words close to the FORCE limit (Figure 4A). Furthermore, in this g range, the error in the output after training increases as a function of g, meaning g = 0 performs best (Figure 4B). For a typical instability of pure echo-state learning, the output matches the target brieﬂy after learning is terminated, but then it deviates away (Figure 4C). Because this stability problem arises from the failure of the network to sample feedback ﬂuctuations, it can be alleviated somewhat by introducing noise into the feedback loop during training (Jaeger and Haas, 2004, introduced noise into the network, which is less effective). Doing this, we ﬁnd that pure echo-state learning converges on about 50% of the trials, but the error on these is signiﬁcantly larger than for pure FORCE learning.\nAdvantages of Chaotic Spontaneous Activity To study the effect of spontaneous chaotic activity on network performance, we introduce a factor g that scales the strengths of the recurrent connections within the network. Networks with g < 1 are inactive prior to training, whereas networks with g > 1 exhibit chaotic spontaneous activity (Sompolinsky et al., 1988) that gets more irregular and ﬂuctuates more rapidly as g is increased beyond 1 (we typically use g = 1.5).\nThe number of cycles required to train a network to generate the periodic target function shown in Figure 3A drops dramatically as a function of g, continuing to fall as g gets larger than 1 (Figure 5A). The average root-mean-square (rms) error, indicating\n\n550 Neuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc.\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\n# periods trained RMS error\n\nA\n100\n80\n60\n40\n20\n0 0. 8\n\n1 1.2 1.4\ng\n\nB\n0.08\n\n0.06\n\n0.04\n\n0.02\n\n0 0. 8\n\n1 1.2 1.4\ng\n\nC\n8\n\n6\n\n4\n\n2\n\n0 0. 8\n\n1 1.2 1.4\ng\n\nFigure 5. Chaos Improves Training Performance Networks with different g values (Experimental Procedures) were trained to produce the output of Figure 3A. Results are plotted against g in the range 0.75 < g < 1.56, where learning converged. (A) Number of cycles of the periodic target function required for training. (B) The RMS error of the network output after training. (C) The length of the readout weight vector jwj after training.\n\nthe difference between the target function and the output of the network after FORCE learning, also decreases with g (Figure 5B). Another measure of training success is the magnitude of the readout weight vector jwj (Figure 5C). Large values of jwj indicate that the solution found by a learning process involves cancellations between large positive and negative contributions. Such solutions tend to be unstable and sensitive to noise. The magnitude of the weight vector falls as a function of g and takes its smallest values in the region g > 1 characterized by chaotic spontaneous activity.\nThese results indicate that networks that are initially in a chaotic state are quicker to train and produce more accurate and robust outputs than nonchaotic networks. Learning works best when g > 1 and, in fact, fails in this example for networks with g < 0.75. This might suggest that the larger the g value the better, but there is an upper limit. Recall that FORCE learning does not work if the feedback from the readout unit to the network fails to suppress the chaos in the network. For any given target function and set of feedback synaptic strengths, there is an upper limit for g beyond which chaos cannot be suppressed by FORCE learning. Indeed, the range of g values in Figure 5 terminates at g = 1.56 because learning did not converge for higher g values due to this problem. Thus, the best value of g for a particular target function is at the ‘‘edge of chaos’’ (Bertschinger and Natschla¨ ger, 2004), that is the g value just below the point where FORCE learning fails to suppress chaotic activity during training.\nDistorted and Delayed Feedback The linear readout unit was introduced into the network model as a stand-in for a more complex, unmodeled peripheral system, in order to deﬁne the output of the network. The critical information provided by the readout unit is the error signal needed to guide weight modiﬁcation, so its biological interpretation should be as a system that computes or estimates the deviation between an action generated by a network and the desired action. However, in the network conﬁguration presented to this point (Figure 1A), the readout unit, in addition to generating the error signal that guides learning, is also the source of feedback. Given that the output in a biological system is actually the result of a large amount of nonlinear processing and that feedback, whether proprioceptive or a motor efference copy, may have to travel a signiﬁcant distance before returning to the network, we begin this section by examining the effect of introducing delays and nonlinear distortions along the feedback pathway from the readout unit to the network neurons.\n\nThe FORCE learning scheme is remarkably robust to distortions introduced along the feedback pathway (Figure 6A). Nonlinear distortions of the feedback signal can be introduced as long as they do not diminish the temporal ﬂuctuations of the output to the point where chaos cannot be suppressed. We have also introduced low-pass ﬁltering into the feedback pathway, which can be quite extreme before the network fails to learn. Delays can be more problematic if they are too long. The critical point is that FORCE learning works as long as the feedback is of an appropriate form to suppress the initial chaos in the network. This means that the feedback really only has to match the period or the duration of the target function and roughly have the same frequency content.\nFORCE Learning with Other Network Architectures Even allowing for distortion and delay, the feedback pathway, originating as it does from the linear readout unit, is a nonbiological element of the network architecture of Figure 1A. To address this problem, we consider two ways of separating the feedback pathway from the linear readout of the network and modeling it more realistically. The ﬁrst is to provide feedback to the network through a second neural network (Figure 1B) rather than via the readout unit. To distinguish the two networks, we call the original network, present in Figure 1A, the generator network and this new network the feedback network. The feedback network has nonlinear, dynamic neurons identical to those of the generator network, and is recurrently connected. Each unit of the feedback network produces a distinct output that is fed back to a subset of neurons in the generator network, so the task of carrying feedback is shared across multiple neurons. This repairs two biologically implausible aspects of the architecture of Figure 1A: the strong feedback synapses mentioned above and the fact that every neuron in the network receives the same feedback signal.\nWhen we include a feedback network (Figure 1B), FORCE learning takes place both on the weights connecting the generator network to the readout unit (as in the architecture of Figure 1A) and on the synapses connecting the generator network to the feedback network (red connections in Figure 1B). Separating feedback from output introduces a credit-assignment problem because changes to the synapses connecting the generator network to the feedback network do not have a direct effect on the output. To solve this problem within the FORCE learning scheme, we treat every neuron subject to synaptic modiﬁcation as if it were the readout unit, even when it is not. In other words, we apply Equations 4 and 5 to every synapse connecting\n\nNeuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc. 551\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\nA\n\nC\n\n1.2sec\nB\n\nFigure 6. Feedback Variants (A) Network trained to produce a periodic output (red trace) when its feedback (cyan trace) is 1.3tanh (sin(pz(tÀ100 ms)), a delayed and distorted function of the output z(t) (gray oval in circuit diagram). (B) FORCE learning with a separate feedback network (circuit diagram). Output is the red trace, and blue traces show activity traces from 5 neurons within the feedback network. (C) A network (circuit diagram) in which the internal synapses are trained to produce the output (red). Activities of ﬁve representative network neurons are in blue. The thick cyan traces are overlays of the component of the input to each of tPhese ﬁve neurons induced by FORCE learning,\niðJijðtÞ À Jijð0ÞÞrjðtÞ for i = 1.. <1..5> 5.\n\n1.2sec\n\n1.2sec\n\nthe generator network to the feedback network (Supplemental Data), and we also apply them to the weights driving the readout unit. When we modify synapses onto a particular neuron of the feedback network, the vector r in these equations is composed of the ﬁring rates of generator network neurons presynaptic to that feedback neuron, and the weight vector w is replaced by the strengths of the synapses it receives from these presynaptic neurons. However, the same error term that originates from the readout (Equation 2) is used in these equations whether they are applied to the weights of the readout unit or synapses onto neurons of the feedback network (Methods). The form of FORCE learning we are using is cell autonomous, so no communication of learning-related information between neurons is required to implement these modiﬁcations, except that they all use a global error signal.\nFORCE learning with a feedback network and independent readout unit can generate complex outputs similar to those in Figure 4, although parameters such as a (Equation 6) may require more careful adjustment. After training, when the output of these networks matches the target function, the activities of neurons in the feedback network do not, despite the fact that their synapses are modiﬁed by the same algorithm as the readout weights (Figure 6B). This difference is due to the fact that the feedback network neurons receive input from each other as well as from the generator network, and these other inputs are not modiﬁed by the FORCE procedure. Differences between the activity of feedback network neurons and the output of the readout unit can also arise from different values of the synapses and the readout weights prior to learning.\nWith a separate feedback network, the feedback to an individual neuron of the generator network is a random combination of the activities of a subset of feedback neurons, summed\n\nthrough random synaptic weights. While these sums bear a certain resemblance to the target function, they are not identical to it nor are they identical for different neurons of the generator network. Nevertheless, FORCE learning works. This extends the result of Figure 6A, showing not only that the feedback does not have to be identical to the network output but that it does not even have to be identical for each neuron of the generator network. Why does this form of learning, in which every neuron with synapses being modiﬁed is treated as if it were producing the output, work? In the example of Figure 6B, the connections from the generator network to the readout unit and to the feedback network are sparse and random (Experimental Procedures), so that neurons in the feedback network do not receive the same inputs from the generator network as the readout unit. However, suppose for a moment that each neuron of the feedback network, as well as the readout unit, received synapses from all of the neurons of the generator network. In this case, the changes to the synapses onto the feedback neurons would be identical to the changes of the weights onto the readout unit and therefore would induce a signal identical to the output into each neuron of the feedback network. This occurs, even though there is no direct connection between these two circuit elements, because the same learning rule with the same global error is being applied in both cases. The explanation of why FORCE learning works in the feedback network when the connections from the generator network are sparse rather than all-to-all (as in Figure 6B) relies on the accuracy of randomly sampling a large system (Sussillo, 2009). With sparse connectivity, each neuron samples a subset of the activities within the full generator network, but if this sample is large enough, it can provide an accurate representation of the leading principal components of the activity of the generator network that drive learning. This is enough information to allow learning to proceed. For Figure 6B, we used an extremely sparse connectivity (Experimental Procedures) to illustrate that FORCE learning can work even when the connections of the units being modiﬁed are highly nonoverlapping.\n\n552 Neuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc.\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\nA\n\npattern 1\n\npattern 2\n\nB\n\nC\n\nD\n\n1.2sec\n\nFigure 7. Multiple Pattern Generation and 4-bit Memory through Learning in the Generator Network (A) Network with control inputs used to produce multiple output patterns (synapses and readout weights that are modiﬁable in red). (B) Five outputs (one cycle of each periodic function made from three sinusoids is shown) generated by a single network and selected by static control inputs. (C) A network with four outputs and eight inputs used to produce a 4-bit memory (modiﬁable synapses and readout weights in red). (D) Red traces are the four outputs, with green traces showing their target values. Purple traces show the eight inputs, divided into ON and OFF pairs associated with the output trace above them. The upper input in each pair turns the corresponding output on (sets it to +1). The lower input of each pair turns the output off (sets it to À1). After learning, the network has implemented a 4-bit memory, with each output responding only to its two inputs while ignoring the other inputs.\n\n1sec\nThe original generator network we used (Figure 1A) is recurrent and can produce its own feedback. This means that we should be able to apply FORCE learning to the synapses of the generator network itself, in the arrangement shown in Figure 1C. To implement FORCE learning within the generator network (Supplemental Data), we modify every synapse in that network using Equations 4 and 5. To apply these equations, the vector w is replaced by the set of synapses onto a particular neuron being modiﬁed, and r is replaced by the vector formed from the ﬁring rates of all the neurons presynaptic to that network neuron. As in the example of learning in the feedback network, FORCE learning is also applied to the readout weights, and the same error, given by Equation 2, is used for every synapse or weight being modiﬁed.\nFORCE learning within the network can produce a complex target output (Figure 6C). An argument similar to that given for learning within the feedback network can be applied to FORCE learning for synapses within the generator network. To illustrate how FORCE learning works, we express the total current into each neuron of the generator network as the sum of two terms. One is the current Pproduced by the original synaptic strengths prior to learning, j Jijð0ÞrjðtÞ for neuron i. The other is the extra current generated by the learning-induced changes\n\nP in these synapses, jðJijðtÞ À Jijð0ÞÞrjðtÞ. The ﬁrst expression, as well as the total current, is different for each neuron of the generator network because of the random initial values of the synaptic strengths. The second, learning-induced current, however, is virtually identical to the target function for each neuron of the network (Figure 6C, cyan). Thus, FORCE learning induces a signal representing the target function into the network, just as it does for the architecture of Figure 1A, but in a subtler and more biologically realistic manner. Output patterns like those in Figure 2 can be reproduced by FORCE learning applied within the generator or feedback networks. In the following sections, we illustrate the capacity of these forms of FORCE learning while, at the same time, introducing new tasks. All of the examples shown can be reproduced using all three of the architectures in Figure 1, but for compactness we show results from learning in the generator network in Figure 7 and learning in the feedback network in Figure 8. For the interested reader, Matlab ﬁles that implement FORCE learning in the different architectures are included with the Supplemental Data.\nSwitching between Multiple Outputs and Input-Output Mapping with Memory The examples to this point have involved a single target function. We can train networks with the architecture of Figure 1C in both sparse and fully connected conﬁgurations (we illustrate the sparse case) to produce multiple functions, with a set of inputs controlling which is generated at any particular time. We do this by introducing static control inputs to the network neurons (Figure 7A) and pairing each desired output function with\n\nNeuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc. 553\n\nA\nrunning\n\nwalking\n\nrunning walking\nC\n\n...\n\nB\n...\nD\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\nFigure 8. Networks that Generate Both Running and Walking Human Motions (A) Either of these two network architectures can be used to generate the running and walking motions (modiﬁable readout weights shown in red), but the upper network is shown. Constant inputs differentiate between running and walking (purple). Each of 95 joint angles is generated through time by one of the 95 readout units (curved arrows). (B) The running motion generated after training. Cyan frames show early and magenta frames late movement phases. (C) Ten sample network neuron activities during the walking motion. (D) The walking motion, with colors as in (B).\n\na particular input pattern (Experimental Procedures). The constant values of the control inputs are chosen randomly. When a particular target function is being either trained or generated, the control inputs to the network are set to the corresponding static pattern and held constant until a different output is desired. The control inputs do not supply any temporal information to the network, they act solely as a switching signal to select a particular output function. The result is a single network that can produce a number of different outputs depending on the values of the control inputs (Figure 7B).\nUp to now, we have treated the network we are studying as a source of what are analogous to motor output patterns. Networks can also generate complex input/output maps when inputs are present. Figure 7C shows a particularly complex example of a network that functions as a 4-bit memory that is robust to input noise. This network has 8 inputs that randomly connect to neurons in the network and are functionally divided into pairs (Experimental Procedures). The input values are held at zero except for short pulses to positive values that act as ON and OFF commands for the four readout units. Starting from the top, input 1 is the ON command for output 1 and input 2 is\n\nits OFF command. Similarly, inputs 3 and 4 are the ON and OFF commands for output 2, and so on. Turning on an output means inducing a transition to a state with a ﬁxed positive value of 1, and turning it off means switching it to À1. After FORCE learning, the inputs correctly turn the appropriate outputs on and off with little crosstalk between inputs and inappropriate outputs (Figure 7C). This occurs despite the random connectivity of the network, which means that the inputs do not segregate into different channels. This example requires the network to have, after learning, 16 different ﬁxed point attractors, one for each of the 42 possible combinations of the four outputs, and the correct transitions between these attractors induced by pulsing the eight inputs.\nA Motion Capture Example Finally, we consider an example of running and walking based on data obtained from human subjects performing these actions while wearing a suit that allows variables such as joint angles to be measured (also studied by Taylor et al., 2006, using a different type of network and learning procedure). These data, from the CMU Motion Capture Library, consist of 95 joint angles measured over hundreds of time steps.\n\n554 Neuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc.\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\nWe implemented this example using all the architectures in Figure 1 in both sparse and fully connected conﬁgurations with similar results (we show a sparse example using the architecture of Figure 1B). Producing all 95 joint angle sequences in the data sets requires that these networks have 95 readout units. For internal learning, subsets of neurons subjected to learning were assigned to each readout unit and trained using the error generated by that unit (Experimental Procedures). Although running and walking might appear to be periodic motions, in fact the joint angles in the real data are nonperiodic. For this reason, we introduced static control inputs to initialize the network prior to starting the running or walking motion. Because we wanted a single network to generate both motions, we also used the control inputs to switch between them, as in Figure 7A. The successfully trained networks produced both motions (Figure 8; for an animated demo showing all the architectures of Figure 1 see the Supplemental Movies) demonstrating that a single chaotic recurrent network can generate multiple, high-dimensional, nonperiodic patterns that resemble complex human motions.\nDISCUSSION\nIn the Introduction, we mentioned that FORCE learning could be viewed either as a model for learning-induced modiﬁcation of biological networks or, more simply, as a method for constructing models of these networks. Our results should be evaluated in light of both of these interpretations.\nFORCE learning solves some, but certainly not all, of the problems associated with applying ideas about learning from mathematical neural networks to biological systems. Biological networks exhibit complex and irregular spontaneous activity that probably has both chaotic and stochastic sources. FORCE learning provides an approach to network training that can be applied under these conditions (see, in particular, Figure 2F). Furthermore, training does not require any reconﬁguration of the network or changes in its dynamics other than the introduction of synaptic modiﬁcation. Finally, the networks constructed by FORCE learning are more stable than in previous approaches.\nFORCE learning relies on an error signal that, in our examples, is based on a readout unit that is not intended to be a realistic circuit element. It is not clear how the error is computed in biological systems. This is a problem for all models of supervised learning. In motor learning, we imagine that the target function is generated by an internal model of a desired movement and that circuitry exists for comparing this internal model with the motor signal generated by the network and for producing a modulatory signal that guides synaptic plasticity. The cerebellum has been proposed as a possible locus for such internal modeling (Miall et al., 1993). Examples like that of Figure 8, which involve multiple outputs, require multiple error signals. For Figure 8, we subdivided the network being trained into different regions in which plasticity was controlled by a different error signal. If the error is carried by a neuromodulator, this would require multiple pathways (though not necessarily multiple modulators) with at least some spatial targeting. If the error signal is transmitted as in the case of the climbing ﬁbers of the cerebellum, multiple error signals are more straightforward to\n\nhandle. Examples with a single output only require a single global error signal.\nIt is also not known how the error signal, once generated, controls synaptic plasticity. Again, this is a problem associated with all models of error- or reward-based learning. FORCE learning adds the condition that this modiﬁcation act rather quickly compared to the timescale of the action being learned, at least during the initial phases of learning. Both because it is under the control of an error signal and because it acts rapidly, the plasticity required does not match that of typical long-term potentiation experiments, and it is a challenge raised by this work to uncover how such rapid plasticity can be realized biologically, or if it is realized at all. Whatever the plasticity mechanism, a key component of FORCE learning is producing the roughly correct output even during the initial stages of training. Analogously, people cannot learn ﬁne manual skills by randomly ﬂailing their arms about and having their movement errors slowly diminish over time, which would be analogous to more conventional network learning schemes. FORCE learning reminds us that motor learning works best when the desired motor action is duplicated as accurately as possible during training.\nThe RLS algorithm we have used is neuron-speciﬁc but not synapse-speciﬁc. By this we mean that the algorithm uses information about all the inputs to a given neuron to guide modiﬁcation of its individual synapses. The algorithm requires some fairly involved calculations, although not matrix inversion. It is possible to use a simpler, synapse-speciﬁc weight modiﬁcation procedure in which the matrix P is replaced by a single learning rate (Supplemental Data). Provided that this scalar rate is adapted over time, FORCE learning can work with such a simpler plasticity mechanism. Nevertheless, RLS is clearly a more powerful algorithm because it adapts the learning rate to the magnitude of different principal components of the network activity. It is possible that a scheme that is simpler and more biologically plausible than RLS can be devised that retains this desirable feature.\nThe architectures of Figures 1B and 1C, where learning occurs within feedback or generator networks, match biological circuits better than that of Figure 1A, where feedback comes directly from the readout unit. A key feature of learning in these cases is that network plasticity is accompanied by plasticity along the output or error-computing pathway. Plasticity in multiple areas (at least two, in these examples) coupled by a common error signal is a basic prediction of the model. It is a curious feature that performance is comparable for all three architectures in Figure 1, despite that fact that the case of Figure 1C involves changing many more synaptic strengths. We do not currently know whether changing synapses within a network offers advantages for the function-generation task. It may, but the modiﬁcation algorithms developed thus far are not powerful enough to exploit these advantages.\nWe now come to an analysis of FORCE learning as a modelbuilding scheme. We have studied how spontaneously active neural networks can be modiﬁed to generate desired outputs and how control inputs can be used to initiate and select among those outputs. Although this has most direct application to motor systems, it can be generalized to a broader picture of\n\nNeuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc. 555\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\ncognitive processing (Yuste et al., 2005; Buonomano and Maass, 2009), as our example of a 4-bit, input-controlled memory suggests.\nGanguli et al. (2008) have discussed the advantages of using an effective delay-line architecture in applications of networks to memory retention. Provided that a feedback loop from the output, as in Figure 1A, is in place, a delay line structure within the generator network should be quite effective for function generation as well. However, because we were interested in networks that generate spontaneous activity even in the absence of the output feedback loop, we did not consider such an arrangement in any detail.\nThe two-step process by which we induced a chaotic network to produce a nonperiodic sequence (Figures 2J and 8) may have an analog in motor and premotor cortex. The brief ﬁxed point that we introduced to terminate chaotic activity results in a sharp drop in the ﬂuctuations of network neurons just before the learned sequence is generated. Churchland et al. (2006) and Churchland and Shenoy (2007a) have reported just such a drop in variability in their recordings from motor and premotor areas in monkeys immediately before they performed a reaching movement. Except in the simplest of examples, the activity of the generator neurons bears little relationship to the output of the network. Trying to link single-neuron responses to motor actions may thus be misguided. Instead, results from our network models suggest that it may be more instructive to study network-wide modes or patterns of activity extracted by principal components analysis of multiunit recordings (Fetz, 1992; Robinson, 1992; Churchland and Shenoy, 2007b).\nThere are some interesting and perhaps unsettling aspects of the networks we have studied. First, the connectivity of the generator network in the architectures of Figures 1A and 1B is completely random, even after the network has been trained to perform a speciﬁc task. It would be extremely difﬁcult to understand how the generator network ‘‘works’’ by analyzing its synaptic connectivity. Even when the synapses of the generator network are modiﬁed (as in Figure 1C), there is no obvious relationship between the task being performed and the connectivity, which is in any case not unique. The lesson here is that the activity, response properties and function of locally connected neurons can be drastically modiﬁed by feedback loops passing through distal networks. Circuits may need to be studied with an eye toward how they modulate each other, rather than how they function in isolation.\nThe architecture of Figure 1B, involving a separate feedback network (basal ganglia or cerebellum), may be a way to keep plasticity from disrupting the generator network (motor cortex), a disruption that would be disastrous for all motor output, not merely the current task being learned. Modiﬁcation of synapses in a second network (as in Figure 1B) may dominate when a motor task is ﬁrst learned, whereas changes within motor cortex (analogous to learning within the network of Figure 1C) may be reserved for ‘‘virtuoso’’ highly trained motor actions. Our examples show the power of adding feedback loops as a way of modifying network activity. Nervous systems often seem to be composed of loops within loops within loops. Because adding a feedback loop leaves the original circuit unchanged, this is a nondestructive yet highly ﬂexible way of\n\nincreasing a behavioral repertoire through learning, as well as during development and evolution.\n\nEXPERIMENTAL PROCEDURES\n\nAll the networks we use are based on ﬁring-rate descriptions of neural activity. To encompass all the models, we write the network equations for the generator network as (note that, in the Results, we called the parameter labeled here as gGG simply g)\n\ntdxi dt\n\n=\n\nÀ\n\nxi\n\n+ gGG\n\nX NG JGij G rj\nj=1\n\n+ gGz JGi z z + gGF\n\nX NF JGiaF sa\na=1\n\n+\n\nX NI JGimI Im\nm=1\n\nfor i = 1,2,.. <1,2,..>,NG with ﬁring rates ri = tanh(xi). For the feedback network,\n\ntdya dt\n\n=\n\nÀ\n\nya\n\n+ gFF\n\nX NF JFabF sb\nb=1\n\n+ gFG\n\nX NG JFaiG ri\ni=1\n\n+\n\nX NI JFamI Im\nm=1\n\nfor a = 1,2,.. <1,2,..>,NF with ﬁring rates sa = tanh(ya). Equation 1 determines z and t = 10 ms. Sometimes we assign a sparseness pz to the readout unit, meaning that a random fraction 1Àpz of the components of w are set and held to zero. The connection matrices are also assigned sparseness parame-\nters, p, meaning that each element is set and held to 0 with probability 1Àp. Nonzero elements of JGG, JGF, JFG, JFF are drawn independently from\nGaussian distributions with zero means and variances equal to the inverses of pGGNG, pGFNF, pFGNG and pFFNF, respectively. Rows of JGI and JFI have a single nonzero element drawn from a Gaussian distribution with zero mean and unit variance. Elements of JGz are drawn from a uniform distribution\nbetween À1 and 1. Nonzero elements of w are set initially either to zero or to values generated by a Gaussian distribution with zero mean and vari-\nance 1/(pzN).\n\nFor Figures 2–5 and 6A NG = 1000, pGG = 0.1, pz = 1, gGz = 1, gGF = 0, a = 1.0, and NI = 0. For Figure 5, gGG was varied, otherwise gGG = 1.5. For Figure 2H, the standard Lorenz attractor model (see Strogatz and Herbert, 1994) was used with s = 10, b = 8/3, and r = 28. The target function was what is conventionally labeled as x divided by 10, to ﬁt it roughly into the range of À1 to 1. For Figure 2J, the two readouts and feedback loops are similar except for different random choices for the strengths of the feedback synapses onto the network neurons. The additional readout unit takes two possible states, one called active in which its output is determined by Equation 1, and another called inactive in which its output is 0. For further discussion of training in this case, see the Supplemental Data.\n\nFor Figure 6B\nNG = 20,000, NF = 95, pGG = 0.1, pGF = 0.25, pFG = 0.025, pFF = 0.25, pz = 0.025, gGG = 1.5, gGF = 1, gFG = 1, gFF = 1.2, a = 1.0, and NI = 0. RLS modiﬁcation was applied to w and JFG.\n\nFor Figure 6C\nNG = 750, pGG = 0.5, pz = 0.5, gGG = 1.5, gGF = 0, a = 1.0, and NI = 0. RLS modiﬁcation was applied to w and JGG.\n\nFor Figure 7B\nNG = 1200, pGG = 0.8, pz = 0.8, gGG = 1.5, gGF = 0, a = 80, and NI = 100. The inputs Im where chosen randomly and uniformly over the range À2 to 2 for inputs generating initialization ﬁxed points, and À0.5 to 0.5 for inputs control the choice of output function. RLS modiﬁcation was applied to w and JGG, but of the 1200 network neurons, 800 were subject to synaptic modiﬁcation of their incoming synapses (due to memory considerations).\n\nFor Figure 7D\nNG = 1200, pGG = 0.8, pz = 1, gGG = 1, gGF = 0, a = 40, and NI = 8. The elements of the control input vector Im had OFF values of 0.0 and ON values of 0.375. RLS modiﬁcation was applied to w and JGG, with 800 of the network neurons\nsubject to synaptic modiﬁcation of their incoming synapses.\n\n556 Neuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc.\n\nNeuron\nGeneral Patterns from Chaotic Networks\n\nFor Figure 8 Although all network variants in Figure 1 were implemented successfully, the following parameters are for the generator-feedback architecture: NG = 5000, NF = 285, pGG = 0.05, pGF = 0.5, pFG = 0.185, pFF = 0.5, pz = 0.185, gGG = 1.5, gGF = 2.0, gFG = 1.0, gFF = 1.5, a = 2.0, and NI = 50. RLS modiﬁcation was applied to w and JFG.\nMotion capture data were downloaded from the Carnegie Mellon University Motion Capture Library (MOCAP) (http://mocap.cs.cmu.edu/). Data set 09_02.amc was used for the running example and data set 08_01.amc for the walking case. The data were preprocessed by a simple moving average ﬁlter to remove discontinuities and then interpolated to ﬁll in to 10 times density, which works better for our continuous time models. The resulting joint angles were transformed into exponential form (see Taylor et al., 2006) and the means were removed. Movement through space was ignored, so we modeled a runner or walker on a treadmill. Four sets of control inputs were used, one each for running and walking and two for initial-value ﬁxed points for these motions. Fixed-point inputs were chosen randomly and uniformly over the range À2 to 2 and control inputs over À0.25 to 0.25.\nSUPPLEMENTAL DATA\nSupplemental Data include two ﬁgures, supplemental text, example Matlab routines, and two movies and can be found with this article online at http:// www.cell.com/neuron/supplemental/S0896-6273(09)00547-9.\nACKNOWLEDGMENTS\nResearch was supported by an NIH Director’s Pioneer Award, part of the NIH Roadmap for Medical Research, through grant number 5-DP1-OD114-02 and by National Institute of Mental Health grant MH-58754. We thank Taro Toyoizumi, Surya Ganguli, Greg Wayne, and Graham Taylor for helpful comments and suggestions.\nAccepted: July 17, 2009 Published: August 26, 2009\nREFERENCES\nAbarbanel, H.D., Creveling, D.R., and Jeanne, J.M. (2008). Estimation of parameters in nonlinear systems using balanced synchronization. Phys. Rev. E Stat. Nonlin. Soft. Matter Physiol. 77, 016208. Atiya, A.F., and Parlos, A.G. (2000). New results on recurrent network training: Unifying the algorithms and accelerating convergence. IEEE Trans. Neural Netw. 11, 697–709. Amit, D.J., and Brunel, N. (1997). Model of global spontaneous activity and local structured activity during delay periods in the cerebral cortex. Cereb. Cortex 7, 237–252. Bertschinger, N., and Natschla¨ ger, T. (2004). Real-time computation at the edge of chaos in recurrent neural networks. Neural Comput. 16, 1413–1436. Brunel, N. (2000). Dynamics of networks of randomly connected excitatory and inhibitory spiking neurons. J. Physiol. (Paris) 94, 445–463. Buonomano, D.V., and Merzenich, M.M. (1995). Temporal information transformed into a spatial code by a neural network with realistic properties. Science 267, 1028–1030. Buonomano, D.V., and Maass, W. (2009). State-dependent computations: spatiotemporal processing in cortical networks. Nat. Rev. Neurosci. 10, 113–125. Churchland, M.M., and Shenoy, K.V. (2007a). Delay of movement caused by disruption of cortical preparatory activity. J. Neurophysiol. 9, 348–359. Churchland, M.M., and Shenoy, K.V. (2007b). Temporal complexity and heterogeneity of single-neuron activity in premotor and motor cortex. J. Neurophysiol. 97, 4235–4257.\n\nChurchland, M.M., Yu, B.M., Ryu, S.I., Santhanam, G., and Shenoy, K.V. (2006). Neural variability in premotor cortex provides a signature of motor preparation. J. Neurosci. 26, 3697–3712.\nDoya, K. (1992). Bifurcations in the learning of recurrent neural networks. IEEE International Symposium on Circuits and Systems 6, 2777–2780.\nFetz, E. (1992). Are movement parameters recognizably coded in the activity of single neurons? Behav. Brain Sci. 15, 679–690.\nGanguli, S., Huh, D., and Sompolinsky, H. (2008). Memory traces in dynamical systems. Proc. Natl. Acad. Sci. USA 105, 18970–18975.\nHaykin, S. (2002). Adaptive Filter Theory (Upper Saddle River, NJ: Prentice Hall).\nHinton, G.E., Osindero, S., and Teh, Y.W. (2006). A fast learning algorithm for deep belief nets. Neural Comput. 18, 1527–1554.\nJaeger, H. (2003). Adaptive nonlinear system identiﬁcation with echo state networks. In Advances in Neural Information Processing Systems 15, S. Becker, S. Thrun, and K. Obermayer, eds. (Cambridge, MA: MIT Press), pp. 593–600.\nJaeger, H., and Haas, H. (2004). Harnessing nonlinearity: predicting chaotic systems and saving energy in wireless communication. Science 304, 78–80.\nMaass, W., Matschlager, T., and Markram, H. (2002). Real-time computing without stable states: a new framework for neural computation based on perturbations. Neural Comput. 14, 2531–2560.\nMaass, W., Joshi, P., and Sontag, E.D. (2007). Computational aspects of feedback in neural circuits. PLoS Comput. Biol. 3, e165. 10.1371/journal.pcbi. 0020165.\nMiall, R.C., Weir, D.J., Wolpert, D.M., and Stein, J.F. (1993). Is the cerebellum a smith predictor? J. Mot. Behav. 25, 203–216.\nMolgedey, L., Schuchhardt, J., and Schuster, H.G. (1992). Suppressing chaos in neural networks by noise. Phys. Rev. Lett. 69, 3717–3719.\nPearlmutter, B. (1989). Learning state space trajectories in recurrent neural networks. Neural Comput. 1, 263–269.\nRobinson, D. (1992). Implications of neural networks for how we think about brain function. Behav. Brain Sci. 15, 644–655.\nRumelhart, D.E., Hinton, G.E., and Williams, R.J. (1986). Learning internal representations by error propagation. In Parallel Distributed Processing: Explorations in the Microstructure of Cognition, Volume 1. D.E. Rumelhart and J.L. McClelland, eds. (Cambridge, MA: MIT Press).\nRumelhart, D.E., and McClelland, J.L., eds. (1986). Parallel Distributed Processing: Explorations in the Microstructure of Cognition, Volume 1 (Cambridge, MA: MIT Press).\nSompolinsky, H., Crisanti, A., and Sommers, H.J. (1988). Chaos in random neural networks. Phys. Rev. Lett. 61, 259–262.\nSussillo, D. (2009). Learning in chaotic recurrent networks. PhD thesis, Columbia University, New York. pp. 93–102.\nStrogatz, S.H., and Herbert, D.E. (1994). Nonlinear Dynamics and Chaos (Reading, MA: Addison-Wesley).\nTaylor, G.W., Hinton, G.E., and Roweis, S. (2006). Modeling human motion using binary latent variables. In Advances in Neural Information Processing Systems 19 (Cambridge, MA: MIT Press), pp. 1370–1378.\nvan Vreeswijk, C., and Sompolinsky, H. (1996). Chaos in neuronal networks with balanced excitatory and inhibitory activity. Science 274, 1724–1726.\nWilliams, R.J., and Zipser, D. (1989). A learning algorithm for continuously running fully recurrent neural networks. Neural Comput. 1, 270–280.\nYuste, R., MacLean, J.N., Smith, J., and Lansner, A. (2005). The cortex as a central pattern generator. Nat. Rev. Neurosci. 6, 477–483.\n\nNeuron 63, 544–557, August 27, 2009 ª2009 Elsevier Inc. 557\n\n"}